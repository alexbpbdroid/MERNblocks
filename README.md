![logo](https://raw.githubusercontent.com/danjamesyee/MERNblocks/master/logoblox.gif)

[Live Website](https://morning-plains-24273.herokuapp.com/#/)

# Blox

#### Blox is a music production application and community that allows people with no musical background or experience to create music and share it with the world.

![homepage](https://raw.githubusercontent.com/danjamesyee/MERNblocks/master/homepage.png)

# Background and Overview

Many people are interested in music, however they lack any musical experience and believe themselves to be musically inept. Enter Blox, a simple and easy way to create music. Blox are the new notes in our new world of music and users can intuitively select the right blox which vary in size, shape and color based on their length and pitch. Put enough blox together and you will have created a whole song! Just by creating a song you join our community of musicians, and your song will be ranked based on user votes. You can also vote on other people's tracks and watch as tracks go up the ranks. 

#### We will need to:

- Build a database to store data for users, music, etc.
- Implement a web application for creation of music using blocks
- Create website where users can create accounts, create, share and edit music, as well as comment and rate other users' music

#### Functionality and MVPS:

- [x] Website with index of selected music and buttons for login/signup
- [x] User authentication: sign up and log in functionality
- [x] Creation/editing/deletion of musical tracks
- [x] Comment CRUD feature on each musical track
- [x] Upvote system for each musical track
- [x] Search functionality by title/username
- [x] Production README

#### Bonus Features:

- [ ] Mobile app
- [ ] Live collaboration
- [ ] Custom musical blocks

# Technologies and Technical Challenges

#### Backend: MongoDB/Mongoose, Express, Node.js

Node allows us to host our web-server, which our frontend uses to send and receive data to and from the backend. We use Express to manage and resolve HTTP requests sent from the frontend. Express routes frontend requests and uses Mongoose to grab data from the database. The data exchanged between our app and the database is managed by Mongoose, a library to format our user, track and block models. The models are then stored on or fetched from MongoDB.

#### Frontend: React, Redux

React provides our team an organized way of structuring our website using components. We use redux to manage the state of those components and to temporarily store data fetched from the database.

#### Audio with [Tone.js](https://tonejs.github.io/)

Tone.js, a framework for creating interactive music in the browser, gives us the ability to create our own tracks, play them back and edit them. The built in synth instrument gives us our whole library of sounds.

#### CSS with Bootstrap

Bootstrap is a popular framework that includes HTML and CSS based design templates which helps us implement simple and responsive components. Using Bootstrap and React-Bootstrap, we are able to provide consistent and effective styling for our forms, buttons, and dropdown menus. In addition, we used SassCSS (SCSS) to add additional personal-stylizing to the components utilized with bootstrap.

#### Drag and Drop with React-beautiful-dnd

Allows us to rearrange musical blocks on the tracks, allowing the user added functionality and interaction in the music creation process.


![gifdnd](https://raw.githubusercontent.com/danjamesyee/MERNblocks/master/dragndrop.gif)

#### Challenges

The main challenge for our team will be building the music creation component of the application. In addition to using data from an external library, we will have to create an intuitive user interface which any user can use to create music. We will also have to collect the musical data generated by users and store it on the database, then allow users to edit and delete it.

The challenge involved with collecting musical data is knowing what kind of data is stored in the backend that is compatible with the musical library. The data we need are the note and duration values. These are the most important building blocks for creating the musical templates, which are used to create musical tracks. We plan to save templates as musical block models, and reference them when creating tracks.

# Features

### Tracks: create, edit, and view tracks.

A track is a collection of musical blocks. These blocks exist in the backend as strings representing both the note value and duration and act musical templates to create a track. After a user adds a collection of blocks on to a track, they can save the track and it is sent to the backend to be stored. On the frontend, creating a track involves maintaining the right blocks for the track in the state, so that it will re-render upon a new block being added. In addition, the drag and drop functionality is integrated into this system by wrapping the whole displayed array of blocks in the drag and drop context and then causing the change of state each time the user moves a block. All this data is then saved into a track as a collection of blocks which can later be retrieved and played again. In order to play the track, we used the Tone.js sound framework to iterate through the array of blocks and play them at the correct time. 

```Javascript
playNote() {
    let track = this.state.track;

    const synth = new Tone.Synth().toMaster();
    let newPart = [];
    let dur = 0;
    track.forEach((block, idx) => {
      if (idx !== 0) {
        if (track[idx - 1].duration === "4n") dur += 0.5;
        if (track[idx - 1].duration === "8n") dur += 0.25;
        if (track[idx - 1].duration === "16n") dur += 0.125;
      }

      newPart.push([dur, block.note]);
    });
    newPart.push([dur + 1, "C4"]);
    this.setState({ playing: true });

    let note = 0;
    Tone.Transport.cancel();

    let part = new Tone.Part((time, pitch) => {
      if (note >= newPart.length - 1 || this.state.playing === false) {
        this.setState({ playing: false });

        Tone.Transport.cancel();
      } else {
        synth.triggerAttackRelease(pitch, "4n", time);
      }
      note++;
    }, newPart);

    part.start();
    Tone.Transport.start();
  }

```



<!-- !YEE -->

### Votes: allow users to upvote or downvote tracks.

A vote instance exists for a user and a track. When a user votes on a track for the first time, a request is sent to the backend to create a vote associated with the user and the track in question. The implementation does not follow standard RESTful practices. Instead of having two routes for upvoting (POST and PATCH), we opted for **one** route (POST) to handle creating or updating votes. If a user has not voted on a track before, the backend creates a new vote instance and sends it to the database. On the other hand, if a user is updating a vote, the backend will update the existing vote instance. We decided to stray away from standard RESTful procedure because we did not want to have to prepopulate a vote instance for each user and track combination just to upvote or downvote on a track.

```Javascript
Vote.findOne({ user: req.user.id, track: req.params.track_id })
  .then((vote) => {
    // vote exists
    if (vote) {
      // update vote rating
      vote.rating = 1;
      vote.save()
        .then(vote => res.json(vote))
        .catch(err => res.status(400).json(err))
    }
    // create vote since it does not exist
    else {
      Vote
        .create({ user: req.user.id, track: req.params.track_id, rating: 1})
        .then(vote => res.json(vote));
    }
  })
```

# Team Daniel

## [Alex Daniel](https://github.com/alexbpbdroid)

## [Daniel Chau](https://github.com/danchau88)

## [Daniel Creppel](https://github.com/dancreppel)

## [Daniel Yee](https://github.com/danjamesyee)
